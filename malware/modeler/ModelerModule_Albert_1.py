# -*- coding: utf-8 -*-

import json
from collections import Counter
import os
import os.path

class AbstractBagOfWordsModeler:
    
    def __init__(self):
        pass

    # Simple normalization function
    def simpleNormalizeBag(self, bag):
        normalizedBag = []
        
        if len(bag) > 0:
            labels, values = zip(*bag)
            totalSum = float(sum(values))
            
            for tpl in bag:
                occurrences = tpl[1]
                normalizedOccurrences = occurrences/totalSum
                normalizedTuple = (tpl[0], normalizedOccurrences)
                normalizedBag.append(normalizedTuple)
            
        return normalizedBag
        
    def buildLexicon(self, corpus):
        lexicon = set()
        for doc in corpus:
            if 'bag_of_words' in doc:
                bagOfWords = doc['bag_of_words']
                if bagOfWords != None:
                    wordsList = list(bagOfWords)
                    for word in wordsList:
                        lexicon.update([word[0]])
                
        return lexicon
        
    def termFrequency(self, term, document):
      return self.freq(term, document)
    
    def freq(self, term, document):
        if document != None:
            for myTuple in document:
                if myTuple[0] == term:
                    return myTuple[1]
        return 0
        
    def build_DocTermMatrix(self, experiment, docsStructList):
        matrix = []
        vocabulary = self.buildLexicon(docsStructList)
        for struct in docsStructList:
            doc = struct['bag_of_words']
            tf_vector = [self.termFrequency(word, doc) for word in vocabulary]
            
            sampleId = struct['sample_id']
            tf_vector.insert(0, sampleId)
            tf_vector.append(experiment.samples['inverse'][sampleId])
            matrix.append(tf_vector)
            
        vocabulary = list(vocabulary)
        vocabulary.insert(0, 'sample_id')
        vocabulary.append('category')
        
        return (vocabulary, matrix)
                
class InstructionBagOfWordsModeler(AbstractBagOfWordsModeler):
    
    def __init__(self):
        pass
    
    # Build tokeinez struct from file
    def buildStruct_FromFile(self, experiment, inputFilesFolder, filename):
        
        bag = None
        
        fileFullNamePath = inputFilesFolder + "/" + filename
        
        assemblyStruct = {}
        assemblyStruct['filename'] = filename
        assemblyStruct['tokenized'] = None
        assemblyStruct['bag_of_words'] = None
        assemblyStruct['sample_id'] = filename
            
        if os.path.exists(fileFullNamePath):
            jsonData = open(fileFullNamePath)
            tokenizedAssembly = json.load(jsonData, encoding="utf-8")
            bag = self.buildBag_FromArray(tokenizedAssembly)
            normalizedModel = self.simpleNormalizeBag(bag.most_common(40))  
    
            
            assemblyStruct['filename'] = filename
            assemblyStruct['tokenized'] = tokenizedAssembly
            assemblyStruct['bag_of_words'] = normalizedModel

        return assemblyStruct

    # Tokenize from file full path
    def buildBag_FromFile(self, fileFullNamePath):
        
        bag = None
        
        if os.path.exists(fileFullNamePath):
            jsonData = open(fileFullNamePath)
            tokenizedAssembly = json.load(jsonData)
            
            bag = self.build_FromArray(tokenizedAssembly)
        
        return bag
        
    # Builds bag of words for single assembly instructions
    def buildBag_FromArray(self, tokenizedAssembly):
        
        bag = Counter()
        
        for token in tokenizedAssembly:
            if 'type' in token:        
                if (token['type'] == 'INSTRUCTION' 
                    and token['name'] != 'dd' and token['name'] != 'call'
					and not any(c.isdigit() for c in token['name'])
					and not any(c=='_' for c in token['name'])
					and not any(c.isupper() for c in token['name'])
					):
                    bag[token['name']] += 1
    
        return bag
        
class CallOperandsBagOfWordsModeler(AbstractBagOfWordsModeler):
    
    def __init__(self):
        pass
       
    # Build bag of words for "call"s operands, target DLL function
    def buildBag_FromArray(self, tokenizedAssembly):
        
        bag = Counter()
    
        for token in tokenizedAssembly:
            if 'type' in token:        
                if token['type'] == 'INSTRUCTION' and token['name'] == 'call':
                    operands = token['operands']                
                    for x in operands:
                        bag[x] +=1 
    
        return bag
